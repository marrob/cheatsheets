--------------------------------------------
Git Parancsok
git push --set-upstream origin <branch>
- A VSC nem veszi észre az uj branchet és nem lehet kiválasztani
1. git fetch
  > kiirja hogy van új branch
  > VSC újrinditíás és git fetch
  > git fetch --all
Többiek dolgoztak
- pull request kérése dev-rol
- robi-branch: git merge origin/dev ( dev változásainak áthozása)
- robi-branch: commitol
--------------------------------------------
Angular
- ng g class model/Category
- ng g service service/Porduct
- ng g page/dashboard
- ng generate class model/hero
- ng generate component watch
- ng generate pipe prefix
- ng generate directive directive/delay
- ng g service service/user
--------------------------------------------
Json-server
json-server --w .\server\heroes.json

- meghivokat kiküldeni: Settings -> Manage Acess ->Invite a colaborator
- meghivo elfogadása, klónozni a repókat
- belépni a könyvtárba
- függoségek letöltése npm i
- barnch létrehozása -dev a fejlesztésnél legyen 
- a dev-bö legyen a további elágazás pl orsi
- mej visssza a dev-be legyen a további elágazás pl mátyás
- paracsor mengynintása 
- git fetch (hogy frissüljön a státusz)
- a helyi szerkeszto jelenleg a main brenchben van
- a helyi szerkesztoben ki kell választani a sajátot pl józsi-t
- manulásian belép egy branchbe: git checkout origin/orsi 
- módosítás
- Commit megjegyzéssel
- a módosíások feltöltése szinkornizáslása 
- mindenkinek a saját branchét érinti a módosítás
- emeljük be orsi munkáját a dev brench-be
- belépünk orsi branchébe és pull request 
- Orsi csinál egy pull requestet,  mibe base:dev, 
New pull request  józsi ból a dev-be k  Józsi munkáját beleteszi a devbe
- merge pull request majd jóváhagyás Confirm
- orsi behuzta a józsi munkáját a dev-be egy pull request segitsgével
- ha kész a munkák akkor beküldünk egy pull request (ezzel jezem hogy kész van, és ezután be kell emelni )
- pull request visszavonása ha valami nem lett jó 
- pull request és revertel vissza lehet voni valakiét

pl.: a dev-be szeretném a mergeleést, 
- akkor a Brench -> Merge Branch és ebbol

--- parancsok --- 
ng new ang-basic-setup
ng generate class model/hero
ng generate component watch
ng generate pipe prefix
ng generate directive directive/delay
ng g service service/user

-- Telepítés ---
-package.json-
"build": "ng build -o"

-angular.json-
npm i bootstrap
npm i font-awesome
"styles": [
    "node_modules/bootstrap/dist/css/bootstrap.min.css",
    "node_modules/font-awesome/css/font-awesome.min.css",
    "src/styles.scss"
],

--- Komponensek ---
- Az angualar komponenseket a Sabalonban (html-fájlban) kell összekötni egymással.
- Az kompnensek változi közül csak azok köthetoek össze amik @Input vagy @Output-al vannak jelölve
- Egy komponens csak a saját komponenséhez tartozó *.ts-fájlban lévo változókat látja
<app-action-button
    [btnClass]="'btn-info'"
    (clicked)="onSelectButtonClick()">
</app-action-button>

--- Dependency Injection ---
product.ts
export class Product {
  id:number;
  name:string;
}
product.service.ts
@Injectable({
    providedIn: 'root'
})
export class ProductService{
  list:Product[]=[
    {0, "Homer Simpson"},
    {1, "Homer Simpson"},
  ]
}
products.component.ts
export class HomeComponent implements OnInit{
  constructor(
    private prService: ProductService
  ){}
  products: Porduct[] = this.prService.list;
}
--- Osztályra globáli változók ---
Osztályon belül, de metóduson kívül mindig this (pl:this.varName) segítségével érjük el a változót
class DataRowComponent{
    @Input() dataRow: User = new User();
    onDeleteButtonClick(): void {
        this.deleteClick.emit(this.dataRow);
    }
}
--- Output Event ---
Kimeno esmemény létrehozása egy komponenshez
export class DataListComponent implements OnInit {
    @Output() selectClick: EventEmitter<User> = new EventEmitter();
    onDeleteButtonClick(user:User ): void {
        this.deleteClick.emit(user);
    }
}

--- Event ---
Esmény castolása
onClick(event:Event):void{
  const text:HTMLButtonElement = <HTMLButtonElement>event.target.textContent;
  console.log(text);
}
vagy
onChangePhrase(event:Event):void{
    this.phrase = (event.target as HTMLInputElement).value;
}

--- Select ---
<ion-item>
  <ion-label>Én vagyok például: </ion-label>
  <ion-select multiple="false" cancelText="Mégsem" okText="Rendben"  (ionChange)="onCurrentUserChanged($event)" >
    <ion-select-option *ngFor="let user of users" value="{{user.name}}"> {{user.name}}</ion-select-option>
  </ion-select>
</ion-item>

onCurrentUserChanged(event:Event){
  const name:string = (event.target as HTMLInputElement).value;
  console.log("onCurrentUserChanged");
  this.configServ.currentUserName = name;
}


--- Input databindig ---
data objektum [key] kulcsával kijelölt adat közötti kétirányú kapcsolat
"banana in the box"
<input type="text" [(ngModel)]="data[key]" >
Ehhez kell a

Can't bind to 'ngModel' since it isn't a known property of 'input'
import { FormsModule } from '@angular/forms';

[...]

@NgModule({
  imports: [
    [...]
    FormsModule
  ],
  [...]
})


--- DOM class ---
DOM osztályhoz új osztály hozzáadása property bind-gel:
<button (click)="onUserCliced()" class="btn" [class]="btnClass">
    <app-icon [icon]="icon"></app-icon>
    {{ text }}
</button>

Felhasználása:
<app-action-button
    [btnClass]="'btn-info'"
    (clicked)="onSelectButtonClick()"
></app-action-button>

--- Pipe ---
@Pipe({
    name: 'prefix'
})
export class PrefixPipe implements PipeTransform {

    transform(value: any, pre: string = "Mr. "): any {
        return `${pre} ${value}`;
    }
}
<h1 appHighlight>
    {{ title | prefix:'Herr. '}}
</h1>

@Pipe({
  name: 'filter'
})
export class FilterPipe implements PipeTransform {
  transform(value: any[], phrase: string, key: string = ''): any {
    if(!Array.isArray(value) || !phrase || !key){
      return value;
    }
    phrase = phrase.toLowerCase();
    return value.filter(item => String(item[key]).toLowerCase().includes(phrase));
  }
}

@Pipe({
    name: 'sorter'
})
export class SorterPipe implements PipeTransform {
  transform(value: any[], key: string): any[] {
    if (!Array.isArray(value) || !key)
      return value;
    key = key.toLowerCase();
    return value.sort((a, b) => {
      if (isNaN(a[key]) || isNaN(b[key])) {
        const a_str: string = ('' + a[key]).toLowerCase();
        const b_str: string = ('' + b[key]).toLowerCase();
        return a_str.localeCompare(b_str);
      }
      else {
        return a[key] - b[key];
      }
    })
  }
}

|-jelekkel választjuk el a különbözo pipeokat
:-jelekkel választuk az paramétereket

<div *ngFor="let user of users | filter:phraseString  :  'name' | sorter:columnKey">
    <td>{{ user.id }}</td>
</div>

vagy 

<ng-container *ngFor="let product of products | filter:phrase:'name'">
   <app-product-card [product]="product"></app-product-card>
</ng-container>
--- *ngIf feltételes DOM ---
<div class = "card user-card" *ngIf="user.id >0">
</div>
--- http client ---
app.moduls.ts
import { HttpClientModule } from '@angular/common/http'
imports: [HttpClientModule]
user.service.ts
@Injectable({
    providedIn: 'root'
})
export class UserService {
  apiUrl:string = 'http://localhost:3000/users';
  constructor(
      private http: HttpClient
  ) { }

  getAll(): Observable<User[]> {

    return this.http.get<User[]>(this.apiUrl);
  }
}
app.component.ts
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})

export class AppComponent {
  title = 'str-client';
    userList$:Observable<User[]> = this.userService.getAll();
  constructor(
      private userService:UserService,
  ){}
}
app.component.html
<pre>{{userList$ |async | json }}</pre>>

--- Routing ---
---
//nav.component.html
<ul class="navbar-nav mr-auto">
  <li routerLinkActive  = "active" 
      [routerLinkActiveOptions]="{exact: true}"
      class="nav-item" >
    <a class="nav-link" routerLink="/">Home </a>
  </li>
  <li routerLinkActive  = "active" 
      [routerLinkActiveOptions]="{exact: true}"
      class="nav-item">
    <a class="nav-link" routerLink = "/heroes">Heroes</a>
  </li>
</ul>

--- Relative route ---
<ion-item *ngFor="let recipe of recipes" [routerLink]="['./', recipe.id]">
--- Home route ---
 <a class="nav-link" routerLink="/">Home </a>
--- Absolute ---
<a class="nav-link" routerLink = "/heroes">Heroes</a>

---
//app-routing.module.ts
const routes: Routes = 
  [{
    path:'',
    component:HomeComponent
  },{
    path:'products-route',
    component:ProductsComponent
  },{
    path:'product-route/:id',
    component:ProductEditorComponent
  },{ 
    path:'**',
    redirectTo:'',
  }];
<!--porducts.component.html-->
valid product route with id: http://localhost:4200/product/2
<td>
  <div class="btn-group">
    <button [routerLink] = "'/product-route/' + product.id"
            class="btn btn-primary">
      <i class="fa fa-edit"></i>
    </button>
  </div>
</td>
---
//product-editor.component.ts
export class ProductEditorComponent implements OnInit {
product:Product = new Product();
  constructor(
    private productService:ProductService, 
    private activatedRoute:ActivatedRoute
    ) { }
  ngOnInit(): void {
   this.activatedRoute.params.subscribe(
      params=> 
          this.productService.getById(params.id).subscribe(
          item =>{
            console.log(item);
            this.product = item || new Product();
          }
        )
     )
  }
}
--- vagy pipe-al ---
// 1. Kiolvasni az id paramétert az url-bol.
// 2. Ezzel a paraméterrel meghívni az EventService.get metódust.
event$: Observable<Event> = this.activatedRoute.params.pipe(
  switchMap( params => this.eventService.get(params.id) )
);

--- vagy így tipusosan ---
product$:Observable<Product> = this.activatedRoute.params.pipe(
  switchMap(params=> {
    if(Number(params.id)===0){
      return of(new Product());
    }
    return this.productService.get(Number(params.id));
  })
)

--- vagy paramMap -al ---
loadedRecipe:Recipe;
constructor(private activatedRoute:ActivatedRoute,
            private recipesService:RecipesService) { }
ngOnInit() {
  this.activatedRoute.paramMap.subscribe(paramMap=>{
    if(!paramMap.has('id')){
      //redirect
      return;
    }
    const recipeId = paramMap.get('id');
    this.loadedRecipe = this.recipesService.getRecipe(id);
  })
}
---
this.eventService.create(event)
  .subscribe(ev => this.router.navigate(['']));

---
<!--product-editor.component.html-->
<div class="row">
  <div class="col-6 offset-3">
    <form>
      <div class="form-group">
        <label for="name">Name</label>
        <input [(ngModel)]="product.name" type="text" name = "name" class="form-control">
        <label for="price">Name</label>
        <input [(ngModel)]="product.price" type="text" name = "price" class="form-control">
        <button class="btn btn-primary" [routerLink] = "'/products-route'">
          <i class="fa fa-arrow-left" aria-hidden="true"></i>
        </button>
      </div>
    </form>
  </div>
</div>

---
jumpToHero(hero:Hero):void{
  this.router.navigateByUrl(`/hero/${hero.id}`);
}

constructor(
  private route: ActivatedRoute,
  private router: Router  ) {}

ngOnInit() {
  const heroId = this.route.snapshot.paramMap.get('id');
  this.hero$ = this.service.getHero(heroId);
}

gotoItems(hero: Hero) {
  const heroId = hero ? hero.id : null;
  // Pass along the hero id if available
  // so that the HeroList component can select that item.
  this.router.navigate(['/heroes', { id: heroId }]);
}
---

--- Routing Traceing ---
imports: [
    RouterModule.forRoot(
      routes,
      { enableTracing: true } // <-- debugging purposes only
    )
]

--- routerLink ---
ez egy abszolut link
[routerLink]="['/', 'places', 'tabs', 'discover', loadedPlaces[0].id]"
így is irhatod
[routerLink]="['/places/tabs/discover/' + loadedPlaces[0].id]"

--- back navigation ---
export class PlaceDetailPage implements OnInit {
  constructor(
    private router:Router,
    private navCtrl:NavController
    ) { }

  ngOnInit() {
  }
  onBookPlace(){
    this.router.navigateByUrl('places/tabs/discover'); 
    this.navCtrl.navigateBack(['/places/tabs/discover']); //Max szerint ez ajánlott
    this.navCtrl.pop(); //ha nincs el?zmény akkor nem tud vissza lépni
  }
}


--- Angualr Form ---
1. 

<div class="form-group col-6">
  <label class="text-warning" for="category">Category:</label>
  <select class="form-control" id="category" name ="category" [(ngModel)]="movie.category" required>
    <option>Drama</option>
    <option>Action</option>
    <option>Fantasy</option>
  </select>
</div>



--- Observable ---
Subject:
- nem kell neki kezdoérték
- könnyü létrhozni
- mükdöése az Observable-hoz hasonlít de könyü kiváltani az eseményt

BehaviorSubject:
 - az Observable-bol szarmzaik 
 - minden frissen felrítakozó megkapja az utolsó állapotot sima Observable ellenében 
 - mindig kell hogy legyen kezdoértéke
 - xxx.next.('uj ertek') segitsegevel lehet új értéket küldeni
Observable:
 - nem kell hogy legyen kezdoértke
 
így értesíheted a felíratkozókat a változásrol:
getAll(): void {
  this.list$.next(this.list);
}

--
import { Injectable } from '@angular/core';
import { Observable, Subscription } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ObservableService {

  ob$: Observable<number> = new Observable((observer) => {
    setInterval(() => {
      observer.next(Math.floor(Math.random() * 20));
    }, 1000);
    setTimeout(() => observer.complete(), 10000);
    setTimeout(() => observer.error('fail'), 5000);
  });
  constructor() {
    const sub: Subscription = this.ob$.subscribe(
      num => console.log("Service-bol", num)
    );
  }
}
--- Subject ---
import { Component, NgModule } from '@angular/core'
import { BrowserModule } from '@angular/platform-browser'
import { Observable, Subject } from 'rxjs/Rx';

@Component({
  selector: 'my-app',
  template: `
    <div>
      <h2>Open the console.</h2>
    </div>
  `,
})
@NgModule({
  imports: [ BrowserModule ],
  declarations: [ App ],
  bootstrap: [ App ]
})
export class App {

  constructor() {}

  let subject = new Subject();

  // Subscribe in Component
  subject.subscribe(next => {
    console.log(next);
  });

  setInterval(() => {
    // Make your auth call and export this from Service
    subject.next(new Date())
  }, 1000)
}


--- Sablon referencia változók ---
jele #
<div class="row">
  <div class="col-8 offset-2">
    <input class="form-control" #search type="text" (keyup)="0">
    <p>{{search.value}}</p>
  </div>
</div>

--- Forms ---
//app.moudls.ts
import { FormsModule } from '@angular/forms';
imports: [FormsModule];

--- Form Input Validate ---
<div class="row">
  <div class="col-6 offset-3">
    <form>
      <div class="form-group">
        <label for="evNameId">Name</label>
        <input id="evNameId" name="name" [(ngModel)]="event.name" type="text" class="form-control"
        required pattern=".{8,}"
        #evNameNgModel = "ngModel">
        <div class = "error-feedback" [hidden] = "evNameNgModel.valid || evNameNgModel.pristine">
          Please chose a username.
        </div>
    </form>
  </div>
</div>

//*.scss
.error-feedback{
  color:red;
  font-style: italic;
}

--- Form Submit ---
<form #eventForm = "ngForm" (ngSubmit) = "onSubmit(eventForm)">
  <button class="btn btn-success" [disabled] = "!eventForm.form.valid" type="submit">submit</button>
  <pre>
    eventForm.form.valid | json: {{eventForm.form.valid |json}}
  </pre>
</form>

onSubmit(form:NgForm):void{
  console.log("event-editor.form.submit.id:",this.event.id);
  this.eventService.update(this.event);
  console.log("event-editor.form.submit.form:",form);
  console.log("event-editor.form.submit.form:",form.value);
}
-- Pop Up ablak ---
Ng Toastr: https://www.npmjs.com/package/ngx-toastr
-- Loading indicator --
https://nils-mehlhorn.de/posts/indicating-loading-the-right-way-in-angular

-- return Observable --
https://angular.io/guide/rx-library
getById(id: number): Observable<Product | undefined > {
//https://angular.io/guide/rx-library
 return this.getAll().pipe(map(items => {
     return items.find(item => id == item.id)}));
}

--- Osztály átadsáa anuglár komponensnek ---

<div class="card-header" class="{{ cardClass }}">
    <div class="ct-chart" id="productsStatusChartId"></div>
</div>

<app-chart-card
  [cardClass] = "'card-header-success'">
</app-chart-card>

--- binding databinding bind ---
https://angular.io/guide/binding-syntax

1.Interpolation, Property, Attribute, Class, Style
{{expression}}
[target]="expression"
bind-target="expression"
2. Event
(target)="statement"
on-target="statement"
3. Two-way
[(target)]="expression"
bindon-target="expression"

--- Input Changes ---


- Ionic
https://ionicframework.com/docs/angular/your-first-app
- Create an App
ionic start be-fit tabs --type=angular --capacitor
- Run the App
ionic serve




--- Cloud Firestore Data ---
https://firebase.google.com/docs/firestore/data-model
- NoSQL

-- Firebase Realtime Database --- 
https://bezkoder.com/angular-11-firebase-crud/
https://www.youtube.com/watch?v=kXYalWgc_rU




https://firebase.google.com/docs/database/admin/retrieve-data
mindenre is van minta
https://stackblitz.com/edit/angular-firebase-example

--- Storage ---
https://bezkoder.com/firebase-storage-angular-10-file-upload/

--- JSON DB ---
{
  "list": [
    {
      "id": 50,
      "name": "Ulrich Tietze -Christoph Schenk"
    }
  ]
}

--- Casting vs Conversion ---
class Test {
    Cast() {   
        let y:any = 5;
        let result = y as string;
        console.log((y as string).toLowerCase());
        console.log("Kasztoltam", result );
    }
    Konvertalt() {   
        let y = 5;
        let result = String(y);
        console.log("Konvertalálam", result );
    }
    Klasszik() {   
        let y = 5;
        let result = '' + y;
        console.log("Klasszik", result );
    }
}
let test = new Test();
test.Cast();
test.Konvertalt();
test.Klasszik();

--- ION GRID ---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Budget Planner</title>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@ionic/core/dist/ionic/ionic.esm.js"></script>
  <script nomodule src="https://cdn.jsdelivr.net/npm/@ionic/core/dist/ionic/ionic.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@ionic/core/css/ionic.bundle.css" />
</head>

<body>
  <ion-app>
    <ion-header>
      <ion-toolbar color="primary">
        <ion-title>Budget Planner</ion-title>
      </ion-toolbar>
    </ion-header>
    <ion-content>
      <ion-grid>
        <ion-row>
          <ion-col size-md="6" offset-md="3"> md méret fölött fél széles és középre igazított
            <ion-card>
              <ion-card-title>
                New expense
              </ion-card-title>
              <ion-card-content>
                <ion-item>
                  <ion-label position="floating">Expense Reason</ion-label>
                  <ion-input type="text"></ion-input>
                </ion-item>
                <ion-item>
                  <ion-label position="floating">Expense Amount</ion-label>
                  <ion-input type="number"></ion-input>
                </ion-item>
              </ion-card-content>
            </ion-card>
          </ion-col>
        </ion-row>
      </ion-grid>
    </ion-content>
  </ion-app>
</body>

</html>

--- Angulár publikálása GitHub Pages funkcióval ---
Hogyan tuodm ki tenni a github pages-re
https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site

Ez kell hogy legyen a repo név: marrob.github.io
https://github.com/marrob/marrob.github.io
Ezen a címen tudod lekérni az oldalt a bönbészoböl:https://marrob.github.io/

új repó az legyen ami github nevem: marrob.github.io
npm run build --prod
csak a legbelso tartalom mappa kell! semmi más

--- nettuts server ---
https://nettuts.hu/jms/cherryApp/porducts
https://nettuts.hu/jms/marrob/products

CORS hiba: a szerver nem engedi meg hogy máshonn küldjenek kérést

fetch('https://nettuts.hu/jms/proba/products').then(
  response=>response.json()
).then(
  data=> console.log(data)
)

--- rxjs operators ---
csak observable-nek van pipe-ja ez a pipe nem ugyan az mint a ng g pipe...
emitálás: az observable értéket ad, button klick is lehet emit, http válasz stb...

of(),
switchMap: ha van belso observable és ha külso emitál valamit, akkor belso cancel?dik
map: nem obeservable tér vissza, ( a map áltlában a lista elemein végez valami m?veletet)
exhaustMap: ami a megvárja hogy belso observable befejezze a dolgát
mergeMap:a külsö observable hozza létre az új szálat -> új konkurens szálon índitja subsricbe
concatMap: külsö observable emitál akkor létrehoz, 


observable.pipe(take(4)): annyiszor veszi az obeservable ahányérték van 
tap() Used when you want to affect outside state with a notification without altering the notification

---
import { fromEvent, interval } from "rxjs";
import { concatMap, take, exhaustMap } from "rxjs/operators";

const clicks = fromEvent(document, "click");
const result = clicks.pipe(exhaustMap(ev => interval(1000).pipe(take(4))));
result.subscribe(x => console.log(x));

// Results in the following:
// (results are not concurrent)
// For every click on the "document" it will emit values 0 to 3 spaced
// on a 1000ms interval
// one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3

--- filter ---
use filter to return property values in an object
https://stackoverflow.com/questions/31201262/use-filter-to-return-property-values-in-an-object

function getShortMessages(messages) {
  return messages
    .filter(function(obj) {
      return obj.message && obj.message.length <= 50;
    })
    .map(function(obj) {
      return obj.message;
    });
}

const getShortMessages = (messages) => messages
  .filter(obj => obj.message.length <= 50)
  .map(obj => obj.message);
  
  
  return list.filter(i=> i.name.includes(name) && i.rating >= rating).map(j=>j.name);

--- Method Exists ---
  const checkMethod = (parent: any, name :string):boolean=>{
    return typeof Object.getPrototypeOf(parent)[name] != 'undefined'
  }

--- Unit Test ---

import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [
        AppComponent
      ],
    }).compileComponents();
  });

  const checkMethod = (parent: any, name :string):boolean=>{
    return typeof Object.getPrototypeOf(parent)[name] != 'undefined'
  }

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have as title 'mókus'`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('mókus');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement;
    expect(compiled.querySelector('.content span').textContent).toContain('mókus app is running!');
  });

  it('should sumirze the orders', ()=>{
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    const orders=[
      { id:1, name:'süt?', amount: 45000 },
      { id:2, name:'vasaló', amount: 14000 },
      { id:3, name:'porszivó', amount: 30000 },
    ];
    expect(app.getSumOfOrders(orders)).toEqual(89000);
  });
});
--- Szopások ---
selectCategory(category){
  let index = this.categoryCardList.findIndex((item)=>{ return item.category == category});
  this.chosenByCategory=this.categoryCardList[index];
}
vs.
selectCategory(category){
  let index = this.categoryCardList.findIndex((item)=>{item.category == category});
  this.chosenByCategory=this.categoryCardList[index];
}

--- Objektum klónoása, hard copy, object clone ---
getPlace(id:string){
  return {...this._places.find( p=>p.id === id)};
}

--- Általános ---
--- ngOnInit ---
mindig egyszer fut le, ezután a cachb?l veszi az oldalt


